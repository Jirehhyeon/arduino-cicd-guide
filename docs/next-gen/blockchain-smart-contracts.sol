// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

/**
 * üõ°Ô∏è Arduino DevOps Î∏îÎ°ùÏ≤¥Ïù∏ Î≥¥Ïïà ÏÉùÌÉúÍ≥Ñ
 * Ïä§ÎßàÌä∏ Ïª®Ìä∏ÎûôÌä∏Î°ú IoT ÎîîÎ∞îÏù¥Ïä§ Ïù∏Ï¶ù, ÏΩîÎìú Í≤ÄÏ¶ù, Î∞∞Ìè¨ Í∏∞Î°ùÏùÑ Í¥ÄÎ¶¨
 */

// üîê IoT ÎîîÎ∞îÏù¥Ïä§ NFT Ïù∏Ï¶ù ÏãúÏä§ÌÖú
contract ArduinoDeviceRegistry is ERC721, Ownable, ReentrancyGuard, Pausable {
    using Counters for Counters.Counter;
    Counters.Counter private _deviceIds;
    
    struct DeviceInfo {
        string deviceType;        // "ESP32", "Arduino Uno", "Raspberry Pi"
        string firmwareHash;      // ÌòÑÏû¨ ÌéåÏõ®Ïñ¥Ïùò IPFS Ìï¥Ïãú
        string hardwareSerial;    // ÌïòÎìúÏõ®Ïñ¥ ÏãúÎ¶¨Ïñº Î≤àÌò∏
        address owner;            // ÎîîÎ∞îÏù¥Ïä§ ÏÜåÏú†Ïûê
        uint256 manufactureDate;  // Ï†úÏ°∞ ÎÇ†Ïßú
        uint256 lastUpdate;       // ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÍ∞Ñ
        bool isActive;            // ÌôúÏÑ± ÏÉÅÌÉú
        string[] deploymentHistory; // Î∞∞Ìè¨ Í∏∞Î°ù
    }
    
    // ÎîîÎ∞îÏù¥Ïä§ ID => ÎîîÎ∞îÏù¥Ïä§ Ï†ïÎ≥¥
    mapping(uint256 => DeviceInfo) public devices;
    
    // ÌïòÎìúÏõ®Ïñ¥ ÏãúÎ¶¨Ïñº => ÎîîÎ∞îÏù¥Ïä§ ID (Ï§ëÎ≥µ Î∞©ÏßÄ)
    mapping(string => uint256) public serialToDeviceId;
    
    // ÏÜåÏú†Ïûê => ÎîîÎ∞îÏù¥Ïä§ ID Î™©Î°ù
    mapping(address => uint256[]) public ownerDevices;
    
    // Ïù¥Î≤§Ìä∏ Ï†ïÏùò
    event DeviceRegistered(uint256 indexed deviceId, string deviceType, address owner);
    event FirmwareUpdated(uint256 indexed deviceId, string oldHash, string newHash);
    event DeviceTransferred(uint256 indexed deviceId, address from, address to);
    event DeviceDeactivated(uint256 indexed deviceId, string reason);
    
    constructor() ERC721("ArduinoDeviceNFT", "ARDUINO") {}
    
    /**
     * ÏÉà IoT ÎîîÎ∞îÏù¥Ïä§ Îì±Î°ù
     */
    function registerDevice(
        string memory _deviceType,
        string memory _firmwareHash,
        string memory _hardwareSerial,
        address _owner
    ) external onlyOwner nonReentrant whenNotPaused returns (uint256) {
        require(bytes(_hardwareSerial).length > 0, "Serial number required");
        require(serialToDeviceId[_hardwareSerial] == 0, "Device already registered");
        
        _deviceIds.increment();
        uint256 newDeviceId = _deviceIds.current();
        
        // NFT ÎØºÌåÖ
        _safeMint(_owner, newDeviceId);
        
        // ÎîîÎ∞îÏù¥Ïä§ Ï†ïÎ≥¥ Ï†ÄÏû•
        devices[newDeviceId] = DeviceInfo({
            deviceType: _deviceType,
            firmwareHash: _firmwareHash,
            hardwareSerial: _hardwareSerial,
            owner: _owner,
            manufactureDate: block.timestamp,
            lastUpdate: block.timestamp,
            isActive: true,
            deploymentHistory: new string[](0)
        });
        
        serialToDeviceId[_hardwareSerial] = newDeviceId;
        ownerDevices[_owner].push(newDeviceId);
        
        emit DeviceRegistered(newDeviceId, _deviceType, _owner);
        return newDeviceId;
    }
    
    /**
     * ÌéåÏõ®Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏ Í∏∞Î°ù
     */
    function updateFirmware(
        uint256 _deviceId,
        string memory _newFirmwareHash,
        string memory _deploymentRecord
    ) external nonReentrant whenNotPaused {
        require(_exists(_deviceId), "Device does not exist");
        require(ownerOf(_deviceId) == msg.sender || owner() == msg.sender, "Not authorized");
        
        DeviceInfo storage device = devices[_deviceId];
        string memory oldHash = device.firmwareHash;
        
        device.firmwareHash = _newFirmwareHash;
        device.lastUpdate = block.timestamp;
        device.deploymentHistory.push(_deploymentRecord);
        
        emit FirmwareUpdated(_deviceId, oldHash, _newFirmwareHash);
    }
    
    /**
     * ÎîîÎ∞îÏù¥Ïä§ ÎπÑÌôúÏÑ±Ìôî
     */
    function deactivateDevice(uint256 _deviceId, string memory _reason) 
        external nonReentrant whenNotPaused {
        require(_exists(_deviceId), "Device does not exist");
        require(ownerOf(_deviceId) == msg.sender || owner() == msg.sender, "Not authorized");
        
        devices[_deviceId].isActive = false;
        emit DeviceDeactivated(_deviceId, _reason);
    }
    
    /**
     * ÎîîÎ∞îÏù¥Ïä§ Ï†ïÎ≥¥ Ï°∞Ìöå
     */
    function getDeviceInfo(uint256 _deviceId) 
        external view returns (DeviceInfo memory) {
        require(_exists(_deviceId), "Device does not exist");
        return devices[_deviceId];
    }
    
    /**
     * ÏÜåÏú†ÏûêÏùò Î™®Îì† ÎîîÎ∞îÏù¥Ïä§ Ï°∞Ìöå
     */
    function getOwnerDevices(address _owner) 
        external view returns (uint256[] memory) {
        return ownerDevices[_owner];
    }
}

// üîí ÏΩîÎìú Í≤ÄÏ¶ù Î∞è Î∞∞Ìè¨ Ïä§ÎßàÌä∏ Ïª®Ìä∏ÎûôÌä∏
contract ArduinoCodeVerification is Ownable, ReentrancyGuard, Pausable {
    
    struct CodeSubmission {
        string ipfsHash;          // ÏÜåÏä§ÏΩîÎìú IPFS Ìï¥Ïãú
        address developer;        // Í∞úÎ∞úÏûê Ï£ºÏÜå
        uint256 timestamp;        // Ï†úÏ∂ú ÏãúÍ∞Ñ
        string version;           // Î≤ÑÏ†Ñ Ï†ïÎ≥¥
        bool isVerified;          // Í≤ÄÏ¶ù ÏôÑÎ£å Ïó¨Î∂Ä
        uint256 verificationScore; // Í≤ÄÏ¶ù Ï†êÏàò (0-100)
        string[] testResults;     // ÌÖåÏä§Ìä∏ Í≤∞Í≥º
        mapping(address => bool) reviewers; // ÏΩîÎìú Î¶¨Î∑∞Ïñ¥Îì§
        uint256 reviewCount;      // Î¶¨Î∑∞ Í∞úÏàò
    }
    
    struct DeploymentRecord {
        uint256 codeSubmissionId; // ÏΩîÎìú Ï†úÏ∂ú ID
        uint256 deviceId;         // ÎåÄÏÉÅ ÎîîÎ∞îÏù¥Ïä§ ID
        address deployer;         // Î∞∞Ìè¨Ïûê
        uint256 timestamp;        // Î∞∞Ìè¨ ÏãúÍ∞Ñ
        bool isSuccessful;        // Î∞∞Ìè¨ ÏÑ±Í≥µ Ïó¨Î∂Ä
        string deploymentHash;    // Î∞∞Ìè¨ Ìï¥Ïãú
        uint256 gasUsed;          // ÏÇ¨Ïö©Îêú Í∞ÄÏä§
    }
    
    using Counters for Counters.Counter;
    Counters.Counter private _submissionIds;
    Counters.Counter private _deploymentIds;
    
    // ÏΩîÎìú Ï†úÏ∂ú Í∏∞Î°ù
    mapping(uint256 => CodeSubmission) public codeSubmissions;
    
    // Î∞∞Ìè¨ Í∏∞Î°ù
    mapping(uint256 => DeploymentRecord) public deploymentRecords;
    
    // Í∞úÎ∞úÏûêÎ≥Ñ Ï†úÏ∂ú Í∏∞Î°ù
    mapping(address => uint256[]) public developerSubmissions;
    
    // ÎîîÎ∞îÏù¥Ïä§Î≥Ñ Î∞∞Ìè¨ Í∏∞Î°ù
    mapping(uint256 => uint256[]) public deviceDeployments;
    
    // Í≤ÄÏ¶ùÏûê Í∂åÌïú Í¥ÄÎ¶¨
    mapping(address => bool) public authorizedVerifiers;
    
    // Ïù¥Î≤§Ìä∏
    event CodeSubmitted(uint256 indexed submissionId, address developer, string ipfsHash);
    event CodeVerified(uint256 indexed submissionId, uint256 score, address verifier);
    event CodeDeployed(uint256 indexed deploymentId, uint256 submissionId, uint256 deviceId);
    event VerifierAdded(address verifier);
    event VerifierRemoved(address verifier);
    
    modifier onlyVerifier() {
        require(authorizedVerifiers[msg.sender] || owner() == msg.sender, "Not authorized verifier");
        _;
    }
    
    constructor() {
        authorizedVerifiers[msg.sender] = true;
    }
    
    /**
     * ÏΩîÎìú Ï†úÏ∂ú
     */
    function submitCode(
        string memory _ipfsHash,
        string memory _version,
        string[] memory _testResults
    ) external nonReentrant whenNotPaused returns (uint256) {
        require(bytes(_ipfsHash).length > 0, "IPFS hash required");
        
        _submissionIds.increment();
        uint256 newSubmissionId = _submissionIds.current();
        
        CodeSubmission storage submission = codeSubmissions[newSubmissionId];
        submission.ipfsHash = _ipfsHash;
        submission.developer = msg.sender;
        submission.timestamp = block.timestamp;
        submission.version = _version;
        submission.isVerified = false;
        submission.verificationScore = 0;
        submission.testResults = _testResults;
        submission.reviewCount = 0;
        
        developerSubmissions[msg.sender].push(newSubmissionId);
        
        emit CodeSubmitted(newSubmissionId, msg.sender, _ipfsHash);
        return newSubmissionId;
    }
    
    /**
     * ÏΩîÎìú Í≤ÄÏ¶ù
     */
    function verifyCode(
        uint256 _submissionId,
        uint256 _score,
        string[] memory _additionalTests
    ) external onlyVerifier nonReentrant whenNotPaused {
        require(_submissionId <= _submissionIds.current(), "Invalid submission ID");
        require(_score <= 100, "Score must be 0-100");
        
        CodeSubmission storage submission = codeSubmissions[_submissionId];
        require(!submission.reviewers[msg.sender], "Already reviewed by this verifier");
        
        submission.reviewers[msg.sender] = true;
        submission.reviewCount++;
        
        // Í≤ÄÏ¶ù Ï†êÏàò ÏóÖÎç∞Ïù¥Ìä∏ (ÌèâÍ∑†)
        submission.verificationScore = (submission.verificationScore + _score) / submission.reviewCount;
        
        // Ï∂îÍ∞Ä ÌÖåÏä§Ìä∏ Í≤∞Í≥º Î≥ëÌï©
        for (uint i = 0; i < _additionalTests.length; i++) {
            submission.testResults.push(_additionalTests[i]);
        }
        
        // Í≤ÄÏ¶ù ÏôÑÎ£å Í∏∞Ï§Ä: Ï†êÏàò 80 Ïù¥ÏÉÅ, Î¶¨Î∑∞ 2Í∞ú Ïù¥ÏÉÅ
        if (submission.verificationScore >= 80 && submission.reviewCount >= 2) {
            submission.isVerified = true;
        }
        
        emit CodeVerified(_submissionId, _score, msg.sender);
    }
    
    /**
     * ÏΩîÎìú Î∞∞Ìè¨ Í∏∞Î°ù
     */
    function recordDeployment(
        uint256 _submissionId,
        uint256 _deviceId,
        bool _isSuccessful,
        string memory _deploymentHash,
        uint256 _gasUsed
    ) external nonReentrant whenNotPaused returns (uint256) {
        require(_submissionId <= _submissionIds.current(), "Invalid submission ID");
        require(codeSubmissions[_submissionId].isVerified, "Code not verified");
        
        _deploymentIds.increment();
        uint256 newDeploymentId = _deploymentIds.current();
        
        deploymentRecords[newDeploymentId] = DeploymentRecord({
            codeSubmissionId: _submissionId,
            deviceId: _deviceId,
            deployer: msg.sender,
            timestamp: block.timestamp,
            isSuccessful: _isSuccessful,
            deploymentHash: _deploymentHash,
            gasUsed: _gasUsed
        });
        
        deviceDeployments[_deviceId].push(newDeploymentId);
        
        emit CodeDeployed(newDeploymentId, _submissionId, _deviceId);
        return newDeploymentId;
    }
    
    /**
     * Í≤ÄÏ¶ùÏûê Ï∂îÍ∞Ä
     */
    function addVerifier(address _verifier) external onlyOwner {
        authorizedVerifiers[_verifier] = true;
        emit VerifierAdded(_verifier);
    }
    
    /**
     * Í≤ÄÏ¶ùÏûê Ï†úÍ±∞
     */
    function removeVerifier(address _verifier) external onlyOwner {
        authorizedVerifiers[_verifier] = false;
        emit VerifierRemoved(_verifier);
    }
    
    /**
     * ÏΩîÎìú Ï†úÏ∂ú Ï†ïÎ≥¥ Ï°∞Ìöå
     */
    function getCodeSubmission(uint256 _submissionId) 
        external view returns (
            string memory ipfsHash,
            address developer,
            uint256 timestamp,
            string memory version,
            bool isVerified,
            uint256 verificationScore,
            string[] memory testResults,
            uint256 reviewCount
        ) {
        require(_submissionId <= _submissionIds.current(), "Invalid submission ID");
        
        CodeSubmission storage submission = codeSubmissions[_submissionId];
        return (
            submission.ipfsHash,
            submission.developer,
            submission.timestamp,
            submission.version,
            submission.isVerified,
            submission.verificationScore,
            submission.testResults,
            submission.reviewCount
        );
    }
    
    /**
     * ÎîîÎ∞îÏù¥Ïä§ Î∞∞Ìè¨ Í∏∞Î°ù Ï°∞Ìöå
     */
    function getDeviceDeployments(uint256 _deviceId) 
        external view returns (uint256[] memory) {
        return deviceDeployments[_deviceId];
    }
    
    /**
     * Í∞úÎ∞úÏûê Ï†úÏ∂ú Í∏∞Î°ù Ï°∞Ìöå
     */
    function getDeveloperSubmissions(address _developer) 
        external view returns (uint256[] memory) {
        return developerSubmissions[_developer];
    }
}

// üéñÔ∏è Í∞úÎ∞úÏûê ÌèâÌåê Î∞è Ïù∏ÏÑºÌã∞Î∏å ÏãúÏä§ÌÖú
contract ArduinoDeveloperReputation is Ownable, ReentrancyGuard {
    
    struct Developer {
        string nickname;
        uint256 totalSubmissions;
        uint256 verifiedSubmissions;
        uint256 successfulDeployments;
        uint256 totalReputationScore;
        uint256 totalEarnings;
        bool isCertified;
        string[] specializations; // ["IoT", "AI", "Blockchain", "Security"]
        mapping(string => uint256) skillLevels; // Í∏∞Ïà†Î≥Ñ Î†àÎ≤® (0-100)
    }
    
    mapping(address => Developer) public developers;
    mapping(address => bool) public registeredDevelopers;
    
    // ÌèâÌåê ÌÜ†ÌÅ∞ (ERC-20)
    string public constant name = "Arduino Reputation Token";
    string public constant symbol = "ART";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;
    
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    
    // Ïù¥Î≤§Ìä∏
    event DeveloperRegistered(address indexed developer, string nickname);
    event ReputationAwarded(address indexed developer, uint256 amount, string reason);
    event SkillLevelUpdated(address indexed developer, string skill, uint256 level);
    event CertificationGranted(address indexed developer);
    
    constructor() {
        totalSupply = 1000000 * 10**decimals; // 100Îßå ÌÜ†ÌÅ∞
        balances[owner()] = totalSupply;
    }
    
    /**
     * Í∞úÎ∞úÏûê Îì±Î°ù
     */
    function registerDeveloper(
        string memory _nickname,
        string[] memory _specializations
    ) external nonReentrant {
        require(!registeredDevelopers[msg.sender], "Already registered");
        require(bytes(_nickname).length > 0, "Nickname required");
        
        Developer storage dev = developers[msg.sender];
        dev.nickname = _nickname;
        dev.specializations = _specializations;
        dev.isCertified = false;
        
        registeredDevelopers[msg.sender] = true;
        
        // Îì±Î°ù Î≥¥ÎÑàÏä§
        _awardReputation(msg.sender, 100 * 10**decimals, "Registration bonus");
        
        emit DeveloperRegistered(msg.sender, _nickname);
    }
    
    /**
     * ÌèâÌåê Ï†êÏàò Î∂ÄÏó¨ (Í≤ÄÏ¶ùÎêú Ï†úÏ∂ú, ÏÑ±Í≥µÏ†Å Î∞∞Ìè¨ Ïãú)
     */
    function awardReputation(
        address _developer,
        uint256 _amount,
        string memory _reason
    ) external onlyOwner {
        _awardReputation(_developer, _amount, _reason);
    }
    
    function _awardReputation(
        address _developer,
        uint256 _amount,
        string memory _reason
    ) internal {
        require(registeredDevelopers[_developer], "Developer not registered");
        
        developers[_developer].totalReputationScore += _amount;
        developers[_developer].totalEarnings += _amount;
        
        // ÌÜ†ÌÅ∞ Ï†ÑÏÜ°
        _transfer(owner(), _developer, _amount);
        
        emit ReputationAwarded(_developer, _amount, _reason);
    }
    
    /**
     * Í∏∞Ïà† Î†àÎ≤® ÏóÖÎç∞Ïù¥Ìä∏
     */
    function updateSkillLevel(
        address _developer,
        string memory _skill,
        uint256 _level
    ) external onlyOwner {
        require(registeredDevelopers[_developer], "Developer not registered");
        require(_level <= 100, "Level must be 0-100");
        
        developers[_developer].skillLevels[_skill] = _level;
        
        emit SkillLevelUpdated(_developer, _skill, _level);
        
        // ÎÜíÏùÄ Î†àÎ≤® Îã¨ÏÑ± Ïãú Ïù∏Ï¶ù Í≤ÄÌÜ†
        _checkCertificationEligibility(_developer);
    }
    
    /**
     * Ïù∏Ï¶ù ÏûêÍ≤© Í≤ÄÌÜ†
     */
    function _checkCertificationEligibility(address _developer) internal {
        Developer storage dev = developers[_developer];
        
        // Ïù∏Ï¶ù Í∏∞Ï§Ä: ÌèâÌåê Ï†êÏàò 10,000 Ïù¥ÏÉÅ, Í≤ÄÏ¶ùÎêú Ï†úÏ∂ú 10Í∞ú Ïù¥ÏÉÅ, ÏÑ±Í≥µÏ†Å Î∞∞Ìè¨ 5Í∞ú Ïù¥ÏÉÅ
        if (dev.totalReputationScore >= 10000 * 10**decimals &&
            dev.verifiedSubmissions >= 10 &&
            dev.successfulDeployments >= 5 &&
            !dev.isCertified) {
            
            dev.isCertified = true;
            
            // Ïù∏Ï¶ù Î≥¥ÎÑàÏä§
            _awardReputation(_developer, 5000 * 10**decimals, "Certification bonus");
            
            emit CertificationGranted(_developer);
        }
    }
    
    /**
     * ERC-20 ÌÜ†ÌÅ∞ Ï†ÑÏÜ°
     */
    function _transfer(address _from, address _to, uint256 _amount) internal {
        require(_from != address(0), "Transfer from zero address");
        require(_to != address(0), "Transfer to zero address");
        require(balances[_from] >= _amount, "Insufficient balance");
        
        balances[_from] -= _amount;
        balances[_to] += _amount;
    }
    
    function transfer(address _to, uint256 _amount) external returns (bool) {
        _transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function balanceOf(address _account) external view returns (uint256) {
        return balances[_account];
    }
    
    /**
     * Í∞úÎ∞úÏûê Ï†ïÎ≥¥ Ï°∞Ìöå
     */
    function getDeveloperInfo(address _developer) 
        external view returns (
            string memory nickname,
            uint256 totalSubmissions,
            uint256 verifiedSubmissions,
            uint256 successfulDeployments,
            uint256 totalReputationScore,
            bool isCertified,
            string[] memory specializations
        ) {
        require(registeredDevelopers[_developer], "Developer not registered");
        
        Developer storage dev = developers[_developer];
        return (
            dev.nickname,
            dev.totalSubmissions,
            dev.verifiedSubmissions,
            dev.successfulDeployments,
            dev.totalReputationScore,
            dev.isCertified,
            dev.specializations
        );
    }
    
    /**
     * Í∏∞Ïà† Î†àÎ≤® Ï°∞Ìöå
     */
    function getSkillLevel(address _developer, string memory _skill) 
        external view returns (uint256) {
        require(registeredDevelopers[_developer], "Developer not registered");
        return developers[_developer].skillLevels[_skill];
    }
}